//!
//! # Network Module
//! This module handles the peer-to-peer (P2P) networking aspects of the blockchain using libp2p.
//! It is responsible for node identity, peer discovery, connection management, and message propagation.

use libp2p::{
    core::upgrade,
    futures::StreamExt,
    gossipsub, identity, kad, noise, request_response, swarm::NetworkBehaviour, swarm::SwarmBuilder,
    tcp, yamux, PeerId, Swarm,
    Transport,
};
use std::collections::hash_map::DefaultHasher;
use std::error::Error;
use std::hash::{Hash, Hasher};
use std::time::Duration;
use tokio::{
    io::{self, AsyncBufReadExt},
    select,
    sync::mpsc,
    time::sleep,
};
use log::{error, info, warn};

/// Defines the combined network behaviour for the blockchain node.
///
/// This struct integrates various libp2p protocols needed for the blockchain:
/// - `gossipsub`: For pub/sub messaging (broadcasting transactions and blocks).
/// - `kademlia`: For peer discovery using a Distributed Hash Table (DHT).
/// - (Future) `request_response`: For direct request/reply interactions (e.g., fetching specific blocks).
#[derive(NetworkBehaviour)]
#[behaviour(to_swarm = "BlockchainBehaviourEvent")]
pub struct BlockchainBehaviour {
    /// Gossipsub protocol instance for message broadcasting.
    gossipsub: gossipsub::Behaviour,
    /// Kademlia DHT protocol instance for peer discovery.
    kademlia: kad::Behaviour<kad::store::MemoryStore>,
    // TODO: Add request_response behaviour when message types are defined
    // request_response: request_response::Behaviour<...>
}

/// Events generated by the `BlockchainBehaviour` and handled by the main event loop.
///
/// This enum aggregates events from the underlying libp2p behaviours.
#[derive(Debug)]
pub enum BlockchainBehaviourEvent {
    /// Events related to the Gossipsub protocol.
    Gossipsub(gossipsub::Event),
    /// Events related to the Kademlia DHT protocol.
    Kademlia(kad::Event),
    // TODO: Add RequestResponse event variant
    // RequestResponse(request_response::Event<...>),
}

// Implement `From` traits to automatically convert specific behaviour events
// into the `BlockchainBehaviourEvent` enum.

impl From<gossipsub::Event> for BlockchainBehaviourEvent {
    fn from(event: gossipsub::Event) -> Self {
        BlockchainBehaviourEvent::Gossipsub(event)
    }
}

impl From<kad::Event> for BlockchainBehaviourEvent {
    fn from(event: kad::Event) -> Self {
        BlockchainBehaviourEvent::Kademlia(event)
    }
}

/* TODO: Implement From for RequestResponse when added
impl From<request_response::Event<...>> for BlockchainBehaviourEvent {
    fn from(event: request_response::Event<...>) -> Self {
        BlockchainBehaviourEvent::RequestResponse(event)
    }
}
*/

/// Builds the libp2p Swarm, configuring the transport, security, multiplexing,
/// and network behaviours (Gossipsub, Kademlia).
///
/// # Arguments
///
/// * `local_key` - The Ed25519 keypair for the local node identity.
///
/// # Returns
///
/// * A `Result` containing the configured `Swarm` or a boxed error.
fn build_swarm(local_key: identity::Keypair) -> Result<Swarm<BlockchainBehaviour>, Box<dyn Error>> {
    let local_peer_id = PeerId::from(local_key.public());

    // Configure the transport stack: TCP -> Noise -> Yamux
    let transport = tcp::tokio::Transport::new(tcp::Config::default().nodelay(true))
        .upgrade(upgrade::Version::V1Lazy)
        .authenticate(noise::Config::new(&local_key)?)
        .multiplex(yamux::Config::default())
        .timeout(Duration::from_secs(20))
        .boxed();

    // Configure Kademlia DHT
    let store = kad::store::MemoryStore::new(local_peer_id);
    let mut kademlia = kad::Behaviour::new(local_peer_id, store);
    // TODO: Add persistent bootstrap nodes from configuration
    kademlia.bootstrap().ok(); // Start the bootstrap process

    // Configure Gossipsub
    let gossipsub_topic = gossipsub::IdentTopic::new("blockchain-updates");
    let message_id_fn = |message: &gossipsub::Message| {
        // Use a simple hash of the message data as the ID
        let mut s = DefaultHasher::new();
        message.data.hash(&mut s);
        gossipsub::MessageId::from(s.finish().to_string())
    };
    let gossipsub_config = gossipsub::ConfigBuilder::default()
        .heartbeat_interval(Duration::from_secs(10))
        .validation_mode(gossipsub::ValidationMode::Strict) // Requires messages to be signed
        .message_id_fn(message_id_fn)
        .build()?;
    let mut gossipsub = gossipsub::Behaviour::new(
        gossipsub::MessageAuthenticity::Signed(local_key.clone()), // Sign messages with our key
        gossipsub_config,
    )?;
    gossipsub.subscribe(&gossipsub_topic)?;

    // Combine the behaviours into the final NetworkBehaviour
    let behaviour = BlockchainBehaviour {
        gossipsub,
        kademlia,
        // TODO: Add request_response here
    };

    // Build the Swarm
    let swarm = SwarmBuilder::with_tokio_executor(transport, behaviour, local_peer_id).build();
    Ok(swarm)
}


/// Starts the network node, initializes libp2p, and runs the main event loop.
///
/// This function sets up logging, generates node identity, builds the Swarm,
/// starts listening for incoming connections, and processes network events indefinitely.
///
/// # Returns
///
/// * An empty `Result` if the node runs indefinitely without fatal errors, or a boxed error.
pub async fn start_network_node() -> Result<(), Box<dyn Error>> {
    // Initialize logging (e.g., using RUST_LOG=info)
    env_logger::init();

    // Generate the local node's identity keypair
    // TODO: Load/save keypair from/to disk for persistent identity
    let local_key = identity::Keypair::generate_ed25519();
    let local_peer_id = PeerId::from(local_key.public());
    info!("Local peer id: {local_peer_id}");

    // Build the Swarm instance
    let mut swarm = build_swarm(local_key)?;

    // Start listening on all available network interfaces for incoming connections
    // Uses TCP port 0, which requests a random available port from the OS.
    swarm.listen_on("/ip4/0.0.0.0/tcp/0".parse()?)?;

    // Main event loop
    loop {
        select! {
            // Process the next event from the Swarm
            event = swarm.select_next_some() => {
                handle_swarm_event(&mut swarm, event).await;
            }
            // Example periodic task: Publish a 'hello' message via Gossipsub
            _ = sleep(Duration::from_secs(30)) => {
                let message_content = format!("Hello from {local_peer_id} at {:?}", std::time::Instant::now());
                let gossipsub_topic = gossipsub::IdentTopic::new("blockchain-updates");
                if let Err(e) = swarm.behaviour_mut().gossipsub.publish(gossipsub_topic.clone(), message_content.as_bytes()) {
                    error!("Failed to publish gossipsub message: {e:?}");
                }
            }
        }
    }
}

/// Handles events generated by the libp2p Swarm.
///
/// This function processes connection events, behaviour-specific events (Kademlia, Gossipsub),
/// and logs relevant information.
///
/// # Arguments
///
/// * `swarm` - A mutable reference to the Swarm instance.
/// * `event` - The SwarmEvent to process.
async fn handle_swarm_event(swarm: &mut Swarm<BlockchainBehaviour>, event: libp2p::swarm::SwarmEvent<BlockchainBehaviourEvent>) {
     match event {
        // Node has started listening on a new address
        libp2p::swarm::SwarmEvent::NewListenAddr { address, .. } => {
            info!("Node listening on {address}");
        }
        // Kademlia DHT events
        libp2p::swarm::SwarmEvent::Behaviour(BlockchainBehaviourEvent::Kademlia(kad_event)) => {
            match kad_event {
                kad::Event::OutboundQueryProgressed { result, .. } => match result {
                    kad::QueryResult::Bootstrap(Ok(kad::BootstrapOk{peer, num_remaining})) => {
                        info!("Kademlia bootstrap OK. Peer: {peer:?}, Remaining: {num_remaining:?}");
                    }
                    kad::QueryResult::Bootstrap(Err(err)) => {
                        warn!("Kademlia bootstrap failed: {err:?}");
                    }
                    kad::QueryResult::GetClosestPeers(Ok(ok)) => {
                        for peer in ok.peers {
                            info!("Kademlia found closest peer: {peer}");
                            // TODO: Attempt to connect to these peers if not already connected
                        }
                    }
                    kad::QueryResult::GetClosestPeers(Err(err)) => {
                        warn!("Kademlia get closest peers failed: {err:?}");
                    }
                    _ => {}
                }
                kad::Event::RoutingUpdated{peer, is_new, ..} => {
                    if is_new {
                        info!("Kademlia added new peer to routing table: {peer}");
                    }
                }
                _ => {}
            }
        }
        // Gossipsub events
        libp2p::swarm::SwarmEvent::Behaviour(BlockchainBehaviourEvent::Gossipsub(gossip_event)) => {
            match gossip_event {
                gossipsub::Event::Message { propagation_source, message_id, message } => {
                    info!(
                        "Gossipsub: Got message: '{}' with id: {} from peer: {:?}",
                        String::from_utf8_lossy(&message.data), // Assuming UTF-8 for now
                        message_id,
                        propagation_source
                    );
                    // TODO: Deserialize message based on type and process (e.g., add to pending tx pool)
                }
                gossipsub::Event::Subscribed { peer_id, topic } => {
                    info!("Gossipsub: Peer {peer_id} subscribed to topic {topic}");
                }
                gossipsub::Event::Unsubscribed { peer_id, topic } => {
                    info!("Gossipsub: Peer {peer_id} unsubscribed from topic {topic}");
                }
                _ => {}
            }
        }
        /* TODO: Handle RequestResponse events
        libp2p::swarm::SwarmEvent::Behaviour(BlockchainBehaviourEvent::RequestResponse(rr_event)) => {
            info!("RequestResponse event: {:?}", rr_event);
        }
        */
        // Connection lifecycle events
        libp2p::swarm::SwarmEvent::ConnectionEstablished { peer_id, endpoint, .. } => {
            info!("Connection established with peer: {peer_id} at {endpoint:?}");
            // Add the connected peer's address to Kademlia so it can be discovered by others
            swarm.behaviour_mut().kademlia.add_address(&peer_id, endpoint.get_remote_address().clone());
        }
        libp2p::swarm::SwarmEvent::ConnectionClosed { peer_id, cause, .. } => {
            warn!("Connection closed with peer: {peer_id}, Cause: {cause:?}");
            // Remove the peer's address from Kademlia? Maybe not immediately.
            // swarm.behaviour_mut().kademlia.remove_address(&peer_id, endpoint.get_remote_address());
        }
        libp2p::swarm::SwarmEvent::IncomingConnection { local_addr, send_back_addr } => {
            info!("Incoming connection from {send_back_addr} to {local_addr}");
        }
        // Error events
        libp2p::swarm::SwarmEvent::IncomingConnectionError { local_addr, send_back_addr, error } => {
            warn!("Incoming connection error from {send_back_addr} to {local_addr}: {error}");
        }
        libp2p::swarm::SwarmEvent::OutgoingConnectionError { peer_id, error } => {
            warn!("Outgoing connection error to {peer_id:?}: {error}");
        }
        libp2p::swarm::SwarmEvent::ListenerError { listener_id, error } => {
            error!("Listener {listener_id:?} error: {error}");
        }
        libp2p::swarm::SwarmEvent::Dialing { peer_id, connection_id } => {
            info!("Dialing peer {peer_id:?} (connection {connection_id:?})");
        }
        _ => {
            // Log other unhandled events if needed for debugging
            // info!("Unhandled Swarm event: {:?}", event);
        }
    }
}


// Note: This is a basic structure. Error handling, state management,
// integration with other modules, and more robust logic are needed.

#[cfg(test)]
mod tests {
    use super::*;
    use libp2p::identity;
    use std::time::Duration;
    use tokio::time::timeout;

    // Basic test to ensure the swarm can be built without panicking.
    #[tokio::test]
    async fn test_build_swarm_success() {
        let _ = env_logger::builder().is_test(true).try_init(); // Initialize logger for tests
        let local_key = identity::Keypair::generate_ed25519();
        match build_swarm(local_key) {
            Ok(_) => info!("Swarm built successfully."),
            Err(e) => panic!("Failed to build swarm: {:?}", e),
        }
    }

    // Test if the node starts listening on an address.
    // This test runs the swarm briefly and checks for the NewListenAddr event.
    #[tokio::test]
    async fn test_node_listens() {
        let _ = env_logger::builder().is_test(true).try_init();
        let local_key = identity::Keypair::generate_ed25519();
        let mut swarm = build_swarm(local_key).expect("Failed to build swarm for listening test");

        // Listen on a loopback address and random port
        swarm.listen_on("/ip4/127.0.0.1/tcp/0".parse().unwrap()).unwrap();

        let listen_timeout = Duration::from_secs(5);
        let mut listening = false;

        // Run the swarm event loop for a short duration or until listening event is received
        match timeout(listen_timeout, async {
            loop {
                // Poll the swarm for the next event
                if let Some(event) = swarm.next().await {
                    match event {
                        libp2p::swarm::SwarmEvent::NewListenAddr { address, .. } => {
                            info!("Test node listening on: {}", address);
                            return true; // Indicate success: listening event received
                        }
                        _ => { /* Ignore other events for this specific test */ }
                    }
                } else {
                    return false; // Stream ended unexpectedly before listening
                }
            }
        }).await {
            Ok(true) => listening = true,
            Ok(false) => warn!("Swarm stream ended before listening event."),
            Err(_) => warn!("Timeout waiting for listening event."),
        }

        assert!(listening, "Node failed to start listening within the timeout.");
    }

    // Placeholder test for basic gossipsub publish/subscribe.
    // Requires two nodes, more complex setup needed for a proper test.
    // This structure shows how such a test *could* be written but is ignored.
    #[tokio::test]
    #[ignore] // Ignored because it requires more setup and coordination
    async fn test_gossipsub_basic_communication() {
        let _ = env_logger::builder().is_test(true).try_init();

        // Setup node 1
        let key1 = identity::Keypair::generate_ed25519();
        let peer_id1 = PeerId::from(key1.public());
        let mut swarm1 = build_swarm(key1).unwrap();
        swarm1.listen_on("/ip4/127.0.0.1/tcp/0".parse().unwrap()).unwrap();

        // Setup node 2
        let key2 = identity::Keypair::generate_ed25519();
        let peer_id2 = PeerId::from(key2.public());
        let mut swarm2 = build_swarm(key2).unwrap();

        let mut addr1 = None;
        let mut received_message = false;

        // Run event loops concurrently
        loop {
            select! {
                // Event loop for Swarm 1
                event1 = swarm1.select_next_some() => {
                    if let libp2p::swarm::SwarmEvent::NewListenAddr { address, .. } = event1 {
                        info!("Swarm 1 listening on {}", address);
                        addr1 = Some(address);
                        // Once Swarm 1 is listening, Swarm 2 can dial it
                        if let Some(a) = addr1.clone() {
                            swarm2.dial(a).unwrap();
                        }
                    }
                    // Add other event handling for Swarm 1 if needed
                }

                // Event loop for Swarm 2
                event2 = swarm2.select_next_some() => {
                    match event2 {
                        libp2p::swarm::SwarmEvent::ConnectionEstablished { peer_id, .. } => {
                            info!("Swarm 2 connected to {}", peer_id);
                            if peer_id == peer_id1 {
                                // Publish a message from Swarm 2 after connecting
                                let topic = gossipsub::IdentTopic::new("blockchain-updates");
                                swarm2.behaviour_mut().gossipsub.publish(topic, "Test Message").unwrap();
                            }
                        }
                        libp2p::swarm::SwarmEvent::Behaviour(BlockchainBehaviourEvent::Gossipsub(gossipsub::Event::Message { message, .. })) => {
                            info!("Swarm 2 received message: {}", String::from_utf8_lossy(&message.data));
                            // This part is less likely in this specific test setup (Swarm 1 should receive)
                        }
                        _ => {}
                    }
                }

                // Check if Swarm 1 received the message (needs modification)
                // This part needs refinement - how to check Swarm 1's state?
                // Maybe use channels to communicate received messages out of the loop.
                // For now, just break after a timeout.
                _ = sleep(Duration::from_secs(10)) => {
                    warn!("Test timeout reached");
                    break;
                }
            }
            // Add a condition to break the loop once the message is received in Swarm 1
            // if received_message { break; }
        }

        // Assert that the message was received (requires proper state checking)
        // assert!(received_message, "Swarm 1 did not receive the gossipsub message");
    }
}

