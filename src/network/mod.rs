//!
//! # Network Module
//! This module handles the peer-to-peer (P2P) networking aspects of the blockchain using libp2p.
//! It is responsible for node identity, peer discovery, connection management, and message propagation.

use libp2p::{
    core::upgrade,
    futures::StreamExt,
    gossipsub::{self, IdentTopic as Topic, PublishError, MessageId},
    identity,
    kad::{self, store::MemoryStore},
    noise, // Feature 'noise' added in Cargo.toml
    // request_response, // Keep for future use
    swarm::{NetworkBehaviour, SwarmEvent}, // SwarmBuilder moved
    tcp,
    yamux,
    // Multiaddr, // Not used currently
    PeerId,
    Swarm,
    SwarmBuilder, // Imported directly as suggested
    Transport,
};
use std::collections::hash_map::DefaultHasher;
use std::error::Error;
use std::hash::{Hash, Hasher};
use std::time::Duration;
use tokio::{
    select,
    // sync::mpsc, // Keep for potential future command channel
    // time::sleep,
};
use log::{error, info, warn, debug};
use serde::{Serialize, Deserialize};

// Import core types needed for network messages
use crate::core::{Block, Transaction, BlockchainError};
use crate::core::Blockchain; // Import Blockchain to interact with it
use std::sync::{Arc, Mutex}; // To share Blockchain state safely

// --- Network Message Definition ---

/// Represents messages exchanged over the P2P network.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NetworkMessage {
    /// Announce a new block to the network.
    NewBlock(Block),
    /// Announce a new transaction to the network.
    NewTransaction(Transaction),
    // TODO: Add messages for request/response (e.g., GetBlocks, BlocksResponse)
}

// --- Topics for Gossipsub ---

/// Topic for broadcasting newly mined blocks.
pub const BLOCKS_TOPIC: &str = "blocks";
/// Topic for broadcasting new transactions.
pub const TRANSACTIONS_TOPIC: &str = "transactions";

// --- Network Behaviour Definition ---

/// Defines the combined network behaviour for the blockchain node.
#[derive(NetworkBehaviour)]
#[behaviour(to_swarm = "BlockchainBehaviourEvent")]
pub struct BlockchainBehaviour {
    gossipsub: gossipsub::Behaviour,
    kademlia: kad::Behaviour<MemoryStore>,
    // TODO: Add request_response behaviour
}

/// Events generated by the `BlockchainBehaviour`.
#[derive(Debug)] // Added derive Debug
pub enum BlockchainBehaviourEvent {
    Gossipsub(gossipsub::Event),
    Kademlia(kad::Event),
    // TODO: Add RequestResponse event variant
}

impl From<gossipsub::Event> for BlockchainBehaviourEvent {
    fn from(event: gossipsub::Event) -> Self {
        BlockchainBehaviourEvent::Gossipsub(event)
    }
}

impl From<kad::Event> for BlockchainBehaviourEvent {
    fn from(event: kad::Event) -> Self {
        BlockchainBehaviourEvent::Kademlia(event)
    }
}

// --- Network Service Helper ---

/// Helper struct to encapsulate network actions like publishing messages.
/// This allows decoupling the publishing logic from the main event loop handler.
pub struct NetworkService<
'a> { // Corrected lifetime syntax
    swarm: &
'a mut Swarm<BlockchainBehaviour>, // Corrected lifetime syntax
}

impl<
'a> NetworkService<
'a> { // Corrected lifetime syntax
    /// Creates a new NetworkService.
    pub fn new(swarm: &
'a mut Swarm<BlockchainBehaviour>) -> Self { // Corrected lifetime syntax
        NetworkService { swarm }
    }

    /// Publishes a block to the network via Gossipsub.
    pub fn publish_block(&mut self, block: &Block) -> Result<(), PublishError> {
        let topic = Topic::new(BLOCKS_TOPIC);
        let message = NetworkMessage::NewBlock(block.clone());
        match bincode::serialize(&message) {
            Ok(serialized) => {
                info!("Publishing block {} to topic {}", block.header.height, BLOCKS_TOPIC);
                self.swarm.behaviour_mut().gossipsub.publish(topic, serialized).map(|_id: MessageId| ())
            }
            Err(e) => {
                error!("Failed to serialize block for publishing: {}", e);
                Err(PublishError::InsufficientPeers) // Placeholder error
            }
        }
    }

    /// Publishes a transaction to the network via Gossipsub.
    pub fn publish_transaction(&mut self, tx: &Transaction) -> Result<(), PublishError> {
        let topic = Topic::new(TRANSACTIONS_TOPIC);
        let message = NetworkMessage::NewTransaction(tx.clone());
        match bincode::serialize(&message) {
            Ok(serialized) => {
                let tx_hash = tx.calculate_hash();
                info!("Publishing transaction {} to topic {}", hex::encode(tx_hash), TRANSACTIONS_TOPIC);
                self.swarm.behaviour_mut().gossipsub.publish(topic, serialized).map(|_id: MessageId| ())
            }
            Err(e) => {
                error!("Failed to serialize transaction for publishing: {}", e);
                Err(PublishError::InsufficientPeers) // Placeholder error
            }
        }
    }
}

// --- Swarm Building Logic ---

/// Builds the libp2p Swarm, configuring transport, security, multiplexing, and behaviours.
fn build_swarm(local_key: identity::Keypair) -> Result<Swarm<BlockchainBehaviour>, Box<dyn Error>> {
    let local_peer_id = PeerId::from(local_key.public());
    info!("Building swarm for Peer ID: {}", local_peer_id);

    let _transport = tcp::tokio::Transport::new(tcp::Config::default().nodelay(true))
        .upgrade(upgrade::Version::V1Lazy)
        .authenticate(noise::Config::new(&local_key)?)
        .multiplex(yamux::Config::default())
        .timeout(Duration::from_secs(20))
        .boxed();

    let store = MemoryStore::new(local_peer_id);
    let mut kademlia = kad::Behaviour::new(local_peer_id, store);
    kademlia.bootstrap().ok();

    let message_id_fn = |message: &gossipsub::Message| {
        let mut s = DefaultHasher::new();
        message.data.hash(&mut s);
        gossipsub::MessageId::from(s.finish().to_string())
    };
    let gossipsub_config = gossipsub::ConfigBuilder::default()
        .heartbeat_interval(Duration::from_secs(10))
        .validation_mode(gossipsub::ValidationMode::Strict)
        .message_id_fn(message_id_fn)
        .build()?;
    let mut gossipsub = gossipsub::Behaviour::new(
        gossipsub::MessageAuthenticity::Signed(local_key.clone()),
        gossipsub_config,
    )?;

    let blocks_topic = Topic::new(BLOCKS_TOPIC);
    let transactions_topic = Topic::new(TRANSACTIONS_TOPIC);
    gossipsub.subscribe(&blocks_topic)?;
    gossipsub.subscribe(&transactions_topic)?;
    info!("Subscribed to Gossipsub topics: {}, {}", BLOCKS_TOPIC, TRANSACTIONS_TOPIC);

    let behaviour = BlockchainBehaviour {
        gossipsub,
        kademlia,
    };

    // Corrected SwarmBuilder usage for libp2p 0.53
    let swarm = SwarmBuilder::with_existing_identity(local_key)
        .with_tokio()
        .with_tcp(
            tcp::Config::default(),
            noise::Config::new,
            yamux::Config::default,
        )?
        .with_behaviour(|_key| behaviour)?
        .with_swarm_config(|c| c.with_idle_connection_timeout(Duration::from_secs(60)))
        .build();

    Ok(swarm)
}

// --- Node Start and Event Loop ---

/// Starts the network node and runs the main event loop.
pub async fn start_network_node(blockchain: Arc<Mutex<Blockchain>>) -> Result<(), Box<dyn Error>> {
    let _ = env_logger::try_init(); // Use try_init to avoid panic

    let local_key = identity::Keypair::generate_ed25519();
    let local_peer_id = PeerId::from(local_key.public());
    info!("Local peer id: {local_peer_id}");

    let mut swarm = build_swarm(local_key)?;

    swarm.listen_on("/ip4/0.0.0.0/tcp/0".parse()?)?;

    // Main event loop
    loop {
        select! {
            event = swarm.select_next_some() => {
                handle_swarm_event(&mut swarm, event, blockchain.clone()).await;
            }
            // TODO: Replace with actual node logic (e.g., mining trigger, API calls)
        }
    }
}

/// Handles events generated by the libp2p Swarm, including processing network messages.
async fn handle_swarm_event(
    swarm: &mut Swarm<BlockchainBehaviour>,
    event: SwarmEvent<BlockchainBehaviourEvent>,
    blockchain: Arc<Mutex<Blockchain>> // Pass blockchain state
) {
    match event {
        SwarmEvent::NewListenAddr { address, .. } => {
            info!("Node listening on {address}");
        }
        SwarmEvent::Behaviour(BlockchainBehaviourEvent::Kademlia(kad_event)) => {
            // Basic Kademlia event logging
            match kad_event {
                kad::Event::OutboundQueryProgressed { result, .. } => match result {
                    kad::QueryResult::Bootstrap(Ok(kad::BootstrapOk{peer, num_remaining})) => {
                        debug!("Kademlia bootstrap OK. Peer: {peer:?}, Remaining: {num_remaining:?}");
                    }
                    kad::QueryResult::Bootstrap(Err(err)) => {
                        warn!("Kademlia bootstrap failed: {err:?}");
                    }
                    _ => {}
                }
                kad::Event::RoutingUpdated{peer, ..} => { // Removed is_new
                    debug!("Kademlia routing table updated for peer: {peer}");
                }
                _ => {}
            }
        }
        SwarmEvent::Behaviour(BlockchainBehaviourEvent::Gossipsub(gossip_event)) => {
            match gossip_event {
                gossipsub::Event::Message { propagation_source: peer_id, message_id, message } => {
                    let topic = message.topic.as_str();
                    debug!("Gossipsub: Received message ID {} from Peer {} on Topic {}", message_id, peer_id, topic);

                    match bincode::deserialize::<NetworkMessage>(&message.data) {
                        Ok(network_message) => {
                            let mut bc_guard = blockchain.lock().expect("Blockchain lock poisoned");
                            let mut network_service = NetworkService::new(swarm);

                            match (topic, network_message) {
                                (BLOCKS_TOPIC, NetworkMessage::NewBlock(block)) => {
                                    info!("Received NewBlock message for height {} from {}", block.header.height, peer_id);
                                    match bc_guard.process_mined_block(block.clone()) {
                                        Ok(_) => {
                                            info!("Successfully processed block received from network.");
                                            drop(bc_guard);
                                            // Optional: Propagate valid block
                                            // if let Err(e) = network_service.publish_block(&block) {
                                            //     error!("Failed to re-publish block {}: {}", block.header.height, e);
                                            // }
                                        }
                                        Err(e) => {
                                            match e {
                                                BlockchainError::Validation(_) | BlockchainError::Consensus(_) => {
                                                    warn!("Invalid block received from {}: {}", peer_id, e);
                                                }
                                                _ => {
                                                    error!("Failed to process block received from {}: {}", peer_id, e);
                                                }
                                            }
                                        }
                                    }
                                }
                                (TRANSACTIONS_TOPIC, NetworkMessage::NewTransaction(tx)) => {
                                    let tx_hash = tx.calculate_hash();
                                    info!("Received NewTransaction message (Hash: {}) from {}", hex::encode(tx_hash), peer_id);
                                    match bc_guard.add_pending_transaction(tx.clone()) {
                                        Ok(added) => {
                                            if added {
                                                info!("Added new transaction {} from network to mempool.", hex::encode(tx_hash));
                                                drop(bc_guard);
                                                // Propagate valid, new transactions
                                                if let Err(e) = network_service.publish_transaction(&tx) {
                                                    error!("Failed to re-publish transaction {}: {}", hex::encode(tx_hash), e);
                                                }
                                            } else {
                                                debug!("Transaction {} from network already in mempool.", hex::encode(tx_hash));
                                            }
                                        }
                                        Err(e) => warn!("Failed to add transaction {} from {}: {}", hex::encode(tx_hash), peer_id, e),
                                    }
                                }
                                (other_topic, msg_type) => {
                                    warn!("Received unexpected message type {:?} on topic {}", msg_type, other_topic);
                                }
                            }
                        }
                        Err(e) => {
                            warn!("Failed to deserialize Gossipsub message from {}: {}", peer_id, e);
                        }
                    }
                }
                gossipsub::Event::Subscribed { peer_id, topic } => {
                    debug!("Gossipsub: Peer {peer_id} subscribed to topic {topic}");
                }
                gossipsub::Event::Unsubscribed { peer_id, topic } => {
                    debug!("Gossipsub: Peer {peer_id} unsubscribed from topic {topic}");
                }
                _ => {}
            }
        }
        SwarmEvent::ConnectionEstablished { peer_id, endpoint, .. } => {
            info!("Connection established with peer: {peer_id} at {endpoint:?}");
            swarm.behaviour_mut().kademlia.add_address(&peer_id, endpoint.get_remote_address().clone());
        }
        SwarmEvent::ConnectionClosed { peer_id, cause, .. } => {
            warn!("Connection closed with peer: {peer_id}, Cause: {cause:?}");
        }
        SwarmEvent::IncomingConnection { local_addr, send_back_addr, .. } => {
            debug!("Incoming connection from {send_back_addr} to {local_addr}");
        }
        SwarmEvent::IncomingConnectionError { local_addr, send_back_addr, error, .. } => {
            warn!("Incoming connection error from {send_back_addr} to {local_addr}: {error}");
        }
        SwarmEvent::OutgoingConnectionError { peer_id, error, .. } => {
            warn!("Outgoing connection error to {peer_id:?}: {error}");
        }
        SwarmEvent::ListenerError { listener_id, error } => {
            error!("Listener {listener_id:?} error: {error}");
        }
        _ => {}
    }
}

